<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - STL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.4.2/gsap.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.5.0/jquery.min.js" crossorigin="anonymous"></script>
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> -
			STL loader test by <a href="https://github.com/aleeper" target="_blank" rel="noopener">aleeper</a>.<br/>
			PR2 head from <a href="http://www.ros.org/wiki/pr2_description">www.ros.org</a>
        </div>
        

		<script type="module">

			import * as THREE from 'https://threejs.org/build/three.module.js';

			import Stats from 'https://threejs.org/examples/jsm/libs/stats.module.js';

            import { STLLoader } from 'https://threejs.org/examples/jsm/loaders/STLLoader.js';
            
            import {OrbitControls} from 'https://threejs.org/examples/jsm/controls/OrbitControls.js'

            import { Reflector } from 'https://threejs.org/examples/jsm/objects/Reflector.js';

            import { TransformControls } from 'https://threejs.org/examples/jsm/controls/TransformControls.js';

            class Draggable extends EventTarget {

                constructor(element, options) {
                    super();
                    this.position = {
                        current: new THREE.Vector2(),
                        start: new THREE.Vector2(),
                        delta: new THREE.Vector2(),
                        previous: new THREE.Vector2(),
                        drag: new THREE.Vector2(),
                    };

                    this.options = Object.assign({
                        convert: true
                    }, options || {});

                    this.element = element;
                    this.touch = null;

                    this.drag = {

                        start: (event) => {

                            if (event.type == 'mousedown' && event.which != 1) return;
                            if (event.type == 'touchstart' && event.touches.length > 1) return;

                            this.setCurrentPosition(event);

                            this.position.start = this.position.current.clone();
                            this.position.delta.set(0, 0);
                            this.position.drag.set(0, 0);

                            this.touch = (event.type == 'touchstart');

                            this._trigger('drag:start')

                            window.addEventListener((this.touch) ? 'touchmove' : 'mousemove', this.drag.move, false);
                            window.addEventListener((this.touch) ? 'touchend' : 'mouseup', this.drag.end, false);
                        },

                        move: (event) => {


                            this.position.previous = this.position.current.clone();


                            this.setCurrentPosition(event);

                            this.position.delta = this.position.current.clone().sub(this.position.previous);
                            this.position.drag = this.position.current.clone().sub(this.position.start);


                            this._trigger('drag:move')

                        },

                        end: (event) => {

                            this.setCurrentPosition(event);

                            this._trigger('drag:end')

                            window.removeEventListener((this.touch) ? 'touchmove' : 'mousemove', this.drag.move, false);
                            window.removeEventListener((this.touch) ? 'touchend' : 'mouseup', this.drag.end, false);

                        },

                    };

                    this.enable();

                    return this;

                }

                enable() {

                    this.element.addEventListener('touchstart', this.drag.start, false);
                    this.element.addEventListener('mousedown', this.drag.start, false);

                    return this;

                }

                disable() {

                    this.element.removeEventListener('touchstart', this.drag.start, false);
                    this.element.removeEventListener('mousedown', this.drag.start, false);

                    return this;

                }

                setCurrentPosition(event) {

                    const dragEvent = event.touches
                        ? (event.touches[0] || event.changedTouches[0])
                        : event;

                    this.position.current.set(dragEvent.pageX, dragEvent.pageY);
                    if (this.options.convert) {
                        this.convertPosition(this.position.current)
                    }

                }

                convertPosition(position) {

                    position.x = (position.x / this.element.offsetWidth) * 2 - 1;
                    position.y = - ((position.y / this.element.offsetHeight) * 2 - 1);

                    return position;

                }

                _trigger(name) {
                    this.dispatchEvent(new CustomEvent(name, { detail: this.position }));
                }

            }
            window.Draggable = Draggable;

			var container, stats, controls;

			var camera, cameraTarget, scene, renderer;

            var colors = {
                C: 0x999999, // core piece
                D: 0xfff7ff, // white
                U: 0xffff41, // yellow
                R: 0xff1836, // red
                F: 0x00b6ff, // blue
                L: 0xff6c0f, // orange
                B: 0x00fd55, // green
            }

			
            function move(from, to, objs) {
                if (objs == undefined) objs = from.children.slice()
                objs.slice().forEach(o => to.attach(o))
            }

            let needRender = false;

			init();
			render();

           

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 30 );
				camera.position.set(7, 6, 10);

				cameraTarget = new THREE.Vector3( 0, 0, 0 );
				
				camera.lookAt( cameraTarget );

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xd1d5db);
				//scene.fog = new THREE.Fog( 0x72645b, 2, 15 );

				// Lights
                var ambient = new THREE.AmbientLight( 0xffffff, 0.7)
                var front = createShadowedLight(6, 6, 6, 0xeeeece, 0.35)
                var back = createShadowedLight(-6, -4, -4, 0xeeeece, 0.35)

                var lights = new THREE.Group()
                lights.add(ambient, front, back)
                window.lights = lights;

                scene.add(lights)

                
                // mirror
                var geometry = new THREE.PlaneBufferGeometry(6, 5);
				var leftMirror = new Reflector( geometry, {
					clipBias: 0.003,
					textureWidth: window.innerWidth * window.devicePixelRatio,
					textureHeight: window.innerHeight * window.devicePixelRatio,
					color: 0x777777
				} );
                leftMirror.position.set(-8, 1.5, 2);
                leftMirror.rotation.y = Math.PI / 2;
                leftMirror.name = "mirror"
                scene.add( leftMirror );
                
                let backMirror = leftMirror.clone
                


				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				// renderer.outputEncoding = THREE.sRGBEncoding;

				//renderer.shadowMap.enabled = true;

				container.appendChild( renderer.domElement );

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.rotateSpeed = 0.2;
                controls.dampingFactor = 0.1;
                controls.enableZoom = true;
                // controls.autoRotate = true;
                controls.autoRotateSpeed = .75;
                controls.addEventListener('change', animate);

                let transform = new TransformControls(camera, renderer.domElement );
                transform.addEventListener( 'change', animate );
                scene.add(transform)

				// stats

				stats = new Stats();
				container.appendChild( stats.dom );
                
                window.addEventListener( 'resize', onWindowResize, false );

                let tl = gsap.timeline({onUpdate: animate});

                var loader = new STLLoader();

                async function load(url) {
                    return new Promise((resolve, reject) => {
                        loader.load(url, resolve, undefined, reject);
                    })
                };

                function cssColor(str){
                    var ctx = document.createElement("canvas").getContext("2d");
                    ctx.fillStyle = str;
                    return ctx.fillStyle;
                }
                Promise.all(['./corner.stl', './edge.stl', './center.stl', './core.stl'].map(load)).then(([corner_g, edge_g, center_g, core_g]) => {
                    corner_g.scale(0.5, 0.5, 0.5);
                    edge_g.scale(0.5, 0.5, 0.5);
                    center_g.scale(0.5, 0.5, 0.5);
                    core_g.scale(0.5, 0.5, 0.5);

                    let core = new THREE.Mesh(core_g);
                    core.name = 'core'

                                        
                    let face = new THREE.Group();
                    let center = new THREE.Mesh(center_g)
                    let corner_facelet = new THREE.Mesh(corner_g);
                    let edge_facelet = new THREE.Mesh(edge_g);
                    face.add(center)
                    for (let i = 0; i < 4; i++) {                        
                        let corner_facelet2 = corner_facelet.clone()
                        let edge_facelet2 = edge_facelet.clone()
                        corner_facelet2.position.set(1, 1, 0);
                        edge_facelet2.position.set(0, 1, 0);
                        face.attach(corner_facelet2)
                        face.attach(edge_facelet2)
                        face.rotateZ(Math.PI/2)
                    }
                    window.face = face

                    let start = new THREE.Vector3(0, 0, -1)
                    face.position.copy(start)
                    let faces = [];
                    for(let i = 0; i < 3; i++) {
                        for (let s = -1; s < 2; s += 2) {
                            let axis = new THREE.Vector3().setComponent(i, s);
                            let q = new THREE.Quaternion().setFromUnitVectors(start, axis);
                            let another = face.clone()
                            another.quaternion.copy(q);
                            another.position.copy(axis)
                            faces.push(another)
                        }
                    }
                    let cube = new THREE.Group();
                    cube.add(...faces)
                    console.log('cube', cube)
                    cube.add(core)
                    scene.add(cube)

                    // attach to scene so it updates position to world
                    faces.forEach(face => move(face, cube, face.children))
                    cube.remove(...faces)
                    window.cube = cube;

                    window.pieces = []

                    let pieces = []
                    for (let x = -1; x < 2; x++) {
                        pieces[x] = pieces[x] || []
                        for (let y = -1; y < 2; y++) {
                            pieces[x][y] = pieces[x][y] || []
                            for (let z = -1; z < 2; z++) {
                                if (pieces[x][y][z] === undefined) {
                                    let piece = new THREE.Group();
                                    piece.position.set(x, y, z);
                                    cube.add(piece)
                                    pieces[x][y][z] = piece
                                }
                            }
                        }
                    }

                    cube.children.slice().forEach(facelet => {
                        if (facelet.type == "Group")  {
                            return;
                        }
                        facelet.position.round();
                        let piece = pieces[facelet.position.x][facelet.position.y][facelet.position.z]
                        piece.attach(facelet)
                    })

                    let coder = new THREE.Vector3(1, 2, 3); // to code faces
                    let direction = new THREE.Vector3()
                    window.meshes = [];
                    cube.traverse(mesh => {
                        if ( mesh instanceof THREE.Mesh ) {
                            mesh.material =  new THREE.MeshPhysicalMaterial({metalness:0, roughness: 0.7, reflectivity: 0.5, transmission: 0.5})
                            mesh.updateWorldMatrix(true);
                            mesh.getWorldDirection(direction)
                            let face = Math.round(direction.dot(coder));
                            if (mesh.name == 'core') face = 0;
                            let color = {0: colors.C, '1': colors.L, '-1': colors.R, '2': colors.D, '-2': colors.U, '3': colors.B, '-3': colors.F }[face]
                            mesh.material.color.set(color)
                            window.meshes.push(mesh)

                        }
                    })

                    let rotation = new THREE.Group();
                    scene.add(rotation);
                    
                    let rotated = cube.children.filter(p => p.position.x == 1)
                    
                    move(cube, rotation, rotated)

                    function roundAngle(angle) {
                        const round = Math.PI / 2;
                        return Math.round( angle / round ) * round;
                    }

                    function roundRotation(rotation) {
                        return rotation.set(roundAngle(rotation.x), roundAngle(rotation.y), roundAngle(rotation.z))
                    }

                    tl.to(rotation.rotation, 3, {x: Math.PI/2}).then(_ => {
                        move(rotation, cube, rotated)
                        rotated.forEach(p => {
                            p.position.round()
                            roundRotation(p.rotation)
                        })
                        rotation.rotation.set(0,0,0)
                        
                        rotated = cube.children.filter(p => p.position.y == 0)
                        move(cube, rotation, rotated)

                        tl.to(rotation.rotation, 3, {y: Math.PI/2, onComplete: _ => {
                            rotated.forEach(p => roundRotation(p.rotation));
                        }});
                    })


                    window.THREE = THREE;
                    window.scene = scene;
                    window.render = render;
                    window.transform = transform; 
                    window.camera = camera;


                    render();
                })

				//


			}

			function createShadowedLight( x, y, z, color, intensity ) {

				var light = new THREE.SpotLight( color, intensity );
				light.position.set( x, y, z );

				light.castShadow = true;

				var d = 2;
				light.shadow.camera.left = - d;
				light.shadow.camera.right = d;
				light.shadow.camera.top = d;
				light.shadow.camera.bottom = - d;

				light.shadow.camera.near = 1;
				light.shadow.camera.far = 4;

                light.shadow.bias = - 0.002;
                
                return light;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
                animate();

			}

			function animate() {
                if (!needRender) {
                    needRender = true;
                    requestAnimationFrame( render );
                }
			}

			function render() {
                needRender = false;
                stats.begin();

                controls.update();

				renderer.render( scene, camera );
                stats.end();

                if(window.animate) animate();
			}

		</script>
	</body>
</html>
