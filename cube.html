<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - STL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.4.2/gsap.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.5.0/jquery.min.js" crossorigin="anonymous"></script>
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> -
			STL loader test by <a href="https://github.com/aleeper" target="_blank" rel="noopener">aleeper</a>.<br/>
			PR2 head from <a href="http://www.ros.org/wiki/pr2_description">www.ros.org</a>
        </div>
        

		<script type="module">

			import * as THREE from 'https://threejs.org/build/three.module.js';

			import Stats from 'https://threejs.org/examples/jsm/libs/stats.module.js';

            import { STLLoader } from 'https://threejs.org/examples/jsm/loaders/STLLoader.js';
            
            import {OrbitControls} from 'https://threejs.org/examples/jsm/controls/OrbitControls.js'

            import { Reflector } from 'https://threejs.org/examples/jsm/objects/Reflector.js';

            import { TransformControls } from 'https://threejs.org/examples/jsm/controls/TransformControls.js';

            class Draggable extends EventTarget {

                constructor(element, options) {
                    super();
                    this.position = {
                        current: new THREE.Vector2(),
                        start: new THREE.Vector2(),
                        delta: new THREE.Vector2(),
                        previous: new THREE.Vector2(),
                        drag: new THREE.Vector2(),
                    };

                    this.options = Object.assign({
                        convert: true
                    }, options || {});

                    this.element = element;
                    this.touch = null;

                    this.drag = {

                        start: (event) => {

                            if (event.type == 'mousedown' && event.which != 1) return;
                            if (event.type == 'touchstart' && event.touches.length > 1) return;

                            this.setCurrentPosition(event);

                            this.position.start = this.position.current.clone();
                            this.position.delta.set(0, 0);
                            this.position.drag.set(0, 0);

                            this.touch = (event.type == 'touchstart');

                            this._trigger('drag:start')

                            window.addEventListener((this.touch) ? 'touchmove' : 'mousemove', this.drag.move, false);
                            window.addEventListener((this.touch) ? 'touchend' : 'mouseup', this.drag.end, false);
                        },

                        move: (event) => {


                            this.position.previous = this.position.current.clone();


                            this.setCurrentPosition(event);

                            this.position.delta = this.position.current.clone().sub(this.position.previous);
                            this.position.drag = this.position.current.clone().sub(this.position.start);


                            this._trigger('drag:move')

                        },

                        end: (event) => {

                            this.setCurrentPosition(event);

                            this._trigger('drag:end')

                            window.removeEventListener((this.touch) ? 'touchmove' : 'mousemove', this.drag.move, false);
                            window.removeEventListener((this.touch) ? 'touchend' : 'mouseup', this.drag.end, false);

                        },

                    };

                    this.enable();

                    return this;

                }

                enable() {

                    this.element.addEventListener('touchstart', this.drag.start, false);
                    this.element.addEventListener('mousedown', this.drag.start, false);

                    return this;

                }

                disable() {

                    this.element.removeEventListener('touchstart', this.drag.start, false);
                    this.element.removeEventListener('mousedown', this.drag.start, false);

                    return this;

                }

                setCurrentPosition(event) {

                    const dragEvent = event.touches
                        ? (event.touches[0] || event.changedTouches[0])
                        : event;

                    this.position.current.set(dragEvent.pageX, dragEvent.pageY);
                    if (this.options.convert) {
                        this.convertPosition(this.position.current)
                    }

                }

                convertPosition(position) {

                    position.x = (position.x / this.element.offsetWidth) * 2 - 1;
                    position.y = - ((position.y / this.element.offsetHeight) * 2 - 1);

                    return position;

                }

                _trigger(name) {
                    this.dispatchEvent(new CustomEvent(name, { detail: this.position }));
                }

            }
            window.Draggable = Draggable;

			var container, stats, controls;

			var camera, cameraTarget, scene, renderer;

            var colors = {
                D: 0xfff7ff, // white
                U: 0xf6e84b, // yellow
                R: 0xe3302d, // red
                F: 0x0ebcf8, // blue
                L: 0xff9d38, // orange
                B: 0x51da6a, // green
            }

            function matrix4Between(v1, v2) {
                var qrot = new THREE.Quaternion();
                qrot.setFromUnitVectors(v1, v2);
                var m4 = new THREE.Matrix4();
                m4.makeRotationFromQuaternion(qrot);
                return m4
            }

            function eulerToVector(euler, x=1, y=0, z=0) {
                let vec = new THREE.Vector3(x, y, z)
                vec.applyEuler(euler);
                vec.x = Math.round(vec.x * 1000) / 1000
                vec.y = Math.round(vec.y * 1000) / 1000
                vec.z = Math.round(vec.z * 1000) / 1000
                
                return vec;
            }

            function worldVec(mesh) {
                let q = new THREE.Quaternion();
                mesh.getWorldQuaternion(q);
                let vec = new THREE.Vector3(1,0,0);
                vec.applyQuaternion(q);
                vec.x = Math.round(vec.x * 1000) / 1000
                vec.y = Math.round(vec.y * 1000) / 1000
                vec.z = Math.round(vec.z * 1000) / 1000

                return vec;
            }


            function buildCornerMesh(corner_g) {
                let cq = (new THREE.Quaternion()).setFromRotationMatrix((new THREE.Matrix4()).lookAt(new THREE.Vector3(-1,-1,1), new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0))).inverse();
                let material = new THREE.MeshLambertMaterial();
                let first = new THREE.Mesh(corner_g, material);
                let second = new THREE.Mesh(corner_g.clone(), material.clone());
                let third = new THREE.Mesh(corner_g.clone(), material.clone());

                // first.quaternion.copy(cq);
                // second.quaternion.set(0.5, 0.5, -0.5, 0.5)
                second.rotation.set(Math.PI / 2, 0, -Math.PI/2)
                // second.quaternion.set(-0.5, -0.5, 0.5, 0.5).premultiply(cq);

                // corner.children[2].quaternion.set(0.5, 0.5, -0.5, -0.5)
                third.rotation.set(-Math.PI / 2, -Math.PI/2, 0)
                // third.quaternion.set(0.5, 0.5, -0.5, 0.5).premultiply(cq);
                
                let group = new THREE.Group();
                group.name = "corner";
                // group.rotation.setFromQuaternion(cq.inverse());

                group.add(first);
                group.add(second);
                group.add(third);

                return group;
            }

            function buildEdgeMesh(edge_g) {
                let cq = (new THREE.Quaternion()).setFromRotationMatrix((new THREE.Matrix4()).lookAt(new THREE.Vector3(0,-1,1), new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0))).inverse();
                let material = new THREE.MeshLambertMaterial();
                let first = new THREE.Mesh(edge_g, material);
                let second = new THREE.Mesh(edge_g.clone(), material.clone());

                //first.quaternion.copy(cq);

                second.rotation.set(Math.PI / 2, 0, -Math.PI)
                // corner.children[1].quaternion.set(0, Math.SQRT1_2, -Math.SQRT1_2, 0)
                //second.quaternion.set(0, Math.SQRT1_2, -Math.SQRT1_2, 0).premultiply(cq);

                let group = new THREE.Group();
                group.name = "edge"
                //group.rotation.setFromQuaternion(cq.inverse());

                group.add(first);
                group.add(second)

                return group;
            }

            function buildCenterMesh(center_g) {
                let material = new THREE.MeshLambertMaterial();
                let first = new THREE.Mesh(center_g, material);
                first.name = "center"
                return first;
            }

			class Face {
				constructor(scene, axis, color, corner, edge, center) {
                    var material = new THREE.MeshPhongMaterial( { color: color, specular: 0x111111, shininess: 200 } );
                    var m4 = matrix4Between(new THREE.Vector3(0,0,1), axis);
                    

//                    [corner, edge, center] = [corner, edge, center].map(g => {
//                        g = g.clone()
//                        g.applyMatrix4(m4);
//                        return g;
//                    })

                    let localAxis = axis = new THREE.Vector3(0,0,1);;
                    function place(geom, angle) {
                        let mesh = new THREE.Mesh(geom.clone(), material);
                        mesh.geometry.rotateZ(angle)
                        mesh.castShadow = true;
    					mesh.receiveShadow = true;
                        scene.add(mesh);                    

                        mesh.rotation.setFromRotationMatrix(m4);
                        return mesh;
                    }
                    
                    this[0] = place(corner, 0);
 /*                   this[1] = place(edge, 0);
                    this[2] = place(corner, -Math.PI/2);
                    this[3] = place(edge, Math.PI/2);
                    this[4] = place(center, 0);
                    this[5] = place(edge, -Math.PI/2);
                    this[6] = place(corner, Math.PI/2);
                    this[7] = place(edge, -Math.PI);
                    this[8] = place(corner, -Math.PI);
                */              }


            }

            let needRender = false;

			init();
			render();

           

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 30 );
				camera.position.set(7, 6, 10);

				cameraTarget = new THREE.Vector3( 0, 0, 0 );
				
				camera.lookAt( cameraTarget );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xEEEEEE );
				//scene.fog = new THREE.Fog( 0x72645b, 2, 15 );

				// Lights
                var ambient = new THREE.AmbientLight( 0xffffff, 0.5)
                var front = new THREE.PointLight( 0xffffff )
                var back = new THREE.PointLight( 0xffffff )
                front.position.set( 6, 8, 6 )
                back.position.set( -10, -8, -6 );

                var lights = new THREE.Group()
                lights.add(ambient, front, back)
                window.lights = lights;

                scene.add(lights)

                
                // mirror
                var geometry = new THREE.PlaneBufferGeometry(6, 5);
				var leftMirror = new Reflector( geometry, {
					clipBias: 0.003,
					textureWidth: window.innerWidth * window.devicePixelRatio,
					textureHeight: window.innerHeight * window.devicePixelRatio,
					color: 0x777777
				} );
                leftMirror.position.set(-8, 1.5, 2);
                leftMirror.rotation.y = Math.PI / 2;
                leftMirror.name = "mirror"
                scene.add( leftMirror );
                
                let backMirror = leftMirror.clone
                


				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;

				renderer.shadowMap.enabled = true;

				container.appendChild( renderer.domElement );

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.rotateSpeed = 0.2;
                controls.dampingFactor = 0.1;
                controls.enableZoom = true;
                // controls.autoRotate = true;
                controls.autoRotateSpeed = .75;
                controls.addEventListener('change', animate);

                let transform = new TransformControls(camera, renderer.domElement );
                transform.addEventListener( 'change', animate );
                scene.add(transform)

				// stats

				stats = new Stats();
				container.appendChild( stats.dom );
                
                window.addEventListener( 'resize', onWindowResize, false );

                let tl = gsap.timeline({onUpdate: animate});

                var loader = new STLLoader();

                async function load(url) {
                    return new Promise((resolve, reject) => {
                        loader.load(url, resolve, undefined, reject);
                    })
                };

                function cssColor(str){
                    var ctx = document.createElement("canvas").getContext("2d");
                    ctx.fillStyle = str;
                    return ctx.fillStyle;
                }
                Promise.all(['./corner.stl', './edge.stl', './center.stl', './core.stl'].map(load)).then(([corner_g, edge_g, center_g, core_g]) => {
                    var material = new THREE.MeshLambertMaterial({color: 0x999999 } );
                    let core = new THREE.Mesh(core_g, material);
                    core.name = 'core'

                    
                    let corner = buildCornerMesh(corner_g);
                    let edge = buildEdgeMesh(edge_g);
                    let center = buildCenterMesh(center_g)
                    
                    window.corner = corner;
                    window.edge = edge;
                    window.center = center;

                    window.pieces = []

                    let up = new THREE.Vector3();
                    let cornerq = (new THREE.Quaternion()).setFromRotationMatrix((new THREE.Matrix4()).lookAt(new THREE.Vector3(-1,-1,1), new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0))).inverse();
                    let edgeq = (new THREE.Quaternion()).setFromRotationMatrix((new THREE.Matrix4()).lookAt(new THREE.Vector3(0,-1,1), new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0))).inverse();
                    let centerq = new THREE.Quaternion().identity()
                    let coreq = centerq;
                    let lookup = {0: [corner, cornerq], 1: [edge, edgeq], 2: [center, centerq], 3: [core, coreq]}
                    for(let x = -1; x < 2; x++) {
                        for (let y = -1; y < 2; y++) {
                            for (let z = -1; z < 2; z++) {
                                // trial and error of why the following works
                                let zeros = (!x)+(!y)+(!z)
                                let [piece, rq] = lookup[zeros]
                                piece = piece.clone();

                                piece.name += `${x+1}${y+1}${z+1}`
                                piece.position.set(x * 2, y * 2, z * 2);
                                
                                // trial and error of why the following works
                                piece.up.y = y;
                                piece.up.x = !y * 1;

                                piece.lookAt(0,0,0);
                                piece.quaternion.multiply(rq)
                                piece.receiveShadow = true;
                                
                                scene.add(piece);
                                
                                window.pieces.push(piece)

                            }
                        }
                    }
             
                    console.log('scene', scene)
                    let coder = new THREE.Vector3(1, 2, 3); // to code faces
                    let direction = new THREE.Vector3()
                    window.meshes = [];
                    scene.traverse(mesh => {
                        if ( mesh instanceof THREE.Mesh ) {
                            if ({'core111': true, mirror: true}[mesh.name] ) {
                                return;
                            }
                            mesh.material = new THREE.MeshPhysicalMaterial({metalness:0, roughness: 0.5, reflectivity: 0.5, transmission: 0.5})
                            mesh.updateWorldMatrix(true);
                            mesh.getWorldDirection(direction)
                            let face = Math.round(direction.dot(coder));
                            console.log('face', face)
                            let color = { '1': colors.L, '-1': colors.R, '2': colors.D, '-2': colors.U, '3': colors.B, '-3': colors.F }[face]
                            mesh.material.color.set(color)
                            window.meshes.push(mesh)

                        }
                    })

                    let rotated = window.pieces.filter(p => p.position.x == 2)
                    let to = new THREE.Group();
                    scene.add(to);
                    let from = scene // better to have a group to rotate the cube as a whole
                    rotated.forEach(p => {
                        scene.remove(p)
                        to.add(p);
                        console.log('rotated1', p.name)
                    })

                    function roundAngle(angle) {
                        const round = Math.PI / 2;
                        return Math.round( angle / round ) * round;
                    }

                    function roundRotation(rotation) {
                        return rotation.set(roundAngle(rotation.x), roundAngle(rotation.y), roundAngle(rotation.z))
                    }

                    tl.to(to.rotation, 3, {x: Math.PI/2}).then(_ => {
                        to.updateMatrixWorld();
                        rotated.forEach(p => {
                            p.applyMatrix4( to.matrixWorld );
                            to.remove(p)
                            p.applyMatrix4( new THREE.Matrix4().getInverse( scene.matrixWorld ) );
                            scene.add(p)
                            p.position.round();
                        })

                        rotated = window.pieces.filter(p => p.position.y == 2)
                        to.rotation.set(0,0,0)
                        rotated.forEach(p => {
                            scene.remove(p)
                            to.add(p);
                            console.log('rotated2', p.name)
                        });

                        tl.to(to.rotation, 3, {y: Math.PI/2, onComplete: _ => {
                            pieces.forEach(p => roundRotation(p.rotation));
                        }});
                    })



                    window.THREE = THREE;
                    window.scene = scene;
                    window.render = render;
                    window.transform = transform; 
                    window.camera = camera;


                    render();
                })

				//


			}

			function addShadowedLight( x, y, z, color, intensity ) {

				var directionalLight = new THREE.DirectionalLight( color, intensity );
				directionalLight.position.set( x, y, z );
				scene.add( directionalLight );

//				directionalLight.castShadow = true;
/*
				var d = 2;
				directionalLight.shadow.camera.left = - d;
				directionalLight.shadow.camera.right = d;
				directionalLight.shadow.camera.top = d;
				directionalLight.shadow.camera.bottom = - d;

				directionalLight.shadow.camera.near = 1;
				directionalLight.shadow.camera.far = 4;

				directionalLight.shadow.bias = - 0.002;
*/
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
                animate();

			}

			function animate() {
                if (!needRender) {
                    needRender = true;
                    requestAnimationFrame( render );
                }
			}

			function render() {
                needRender = false;
                stats.begin();

                controls.update();

				renderer.render( scene, camera );
                stats.end();

                if(window.animate) animate();
			}

		</script>
	</body>
</html>
